package walk

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gongc/go/models"
)

const controlerTemplate = `// generated by genController.go
package controllers

import (
	"net/http"

	"{{PkgPathRoot}}/models"
	"{{PkgPathRoot}}/orm"

	"github.com/gin-gonic/gin"
	"github.com/jinzhu/gorm"
)

// {{Structname}}Singloton is the type of the singloton of the controllers package
// this singloton allows for the attachment of callbacks to controllers function
type {{Structname}}Singloton struct {
	Callback {{Structname}}CallbackInterface
}

// {{Structname}}CallbackInterface is the interface that must be supported 
// by the Struct that is attached to the singloton
type {{Structname}}CallbackInterface interface {
	Post{{Structname}}({{structname}} *models.{{Structname}})
}

// {{Structname}}SinglotonID is the singloton variable
var {{Structname}}SinglotonID {{Structname}}Singloton

// An {{Structname}}ID parameter model.
//
// This is used for operations that want the ID of an order in the path
// swagger:parameters get{{Structname}} update{{Structname}} delete{{Structname}}{{AssociationControllerIDs}}
type {{Structname}}ID struct {
	// The ID of the order
	//
	// in: path
	// required: true
	ID int64
}

// {{Structname}}Input is a schema that can validate the userâ€™s
// input to prevent us from getting invalid data
// swagger:parameters post{{Structname}} update{{Structname}}
type {{Structname}}Input struct {
	// The {{Structname}} to submit or modify
	// in: body
	{{Structname}} *orm.{{Structname}}API
}

// Get{{Structname}}s
//
// swagger:route GET /{{structname}}s {{structname}}s get{{Structname}}s
// 
// Get all {{structname}}s
//
// Responses:
//    default: genericError
//        200: {{structname}}DBsResponse
func Get{{Structname}}s(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	var {{structname}}s []orm.{{Structname}}DB
	query := db.Find(&{{structname}}s)
	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	c.JSON(http.StatusOK, {{structname}}s)
}

// Post{{Structname}}
//
// swagger:route POST /{{structname}}s {{structname}}s post{{Structname}}
// 
// Creates a {{structname}}
//     Consumes:
//     - application/json
//
//     Produces:
//     - application/json
//
//     Responses:
//       200: {{structname}}DBResponse
func Post{{Structname}}(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Validate input
	var input orm.{{Structname}}API

	err := c.ShouldBindJSON(&input)
	if err != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = err.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// Create {{structname}}
	{{structname}}DB := orm.{{Structname}}DB{}
	{{structname}}DB.{{Structname}}API = input

	query := db.Create(&{{structname}}DB)
	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	if {{Structname}}SinglotonID.Callback != nil {
		{{Structname}}SinglotonID.Callback.Post{{Structname}}(&({{structname}}DB.{{Structname}}))
	}

	c.JSON(http.StatusOK, {{structname}}DB)
}

// Get{{Structname}}
//
// swagger:route GET /{{structname}}s/{ID} {{structname}}s get{{Structname}}
//
// Gets the details for a {{structname}}.
//
// Responses:
//    default: genericError
//        200: {{structname}}DBResponse
func Get{{Structname}}(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Get {{structname}} in DB
	var {{structname}} orm.{{Structname}}DB
	if err := db.First(&{{structname}}, c.Param("id")).Error; err != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = err.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	c.JSON(http.StatusOK, {{structname}})
}

// Update{{Structname}}
// 
// swagger:route PATCH /{{structname}}s/{ID} {{structname}}s update{{Structname}}
//
// Update a {{structname}}
//
// Responses:
//    default: genericError
//        200: {{structname}}DBResponse
func Update{{Structname}}(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Get model if exist
	var {{structname}}DB orm.{{Structname}}DB

	// fetch the {{structname}}
	query := db.First(&{{structname}}DB, c.Param("id"))

	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// Validate input
	var input orm.{{Structname}}API
	if err := c.ShouldBindJSON(&input); err != nil {
		c.JSON(http.StatusBadRequest, gin.H{"error": err.Error()})
		return
	}

	// update 
	query = db.Model(&{{structname}}DB).Updates(input)
	if query.Error != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = query.Error.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}	

	// return status OK with the marshalling of the the {{structname}}DB
	c.JSON(http.StatusOK, {{structname}}DB)
}

// Delete{{Structname}}
//
// swagger:route DELETE /{{structname}}s/{ID} {{structname}}s delete{{Structname}}
//
// Delete a {{structname}}
//
// Responses:
//    default: genericError
func Delete{{Structname}}(c *gin.Context) {
	db := c.MustGet("db").(*gorm.DB)

	// Get model if exist
	var {{structname}}DB orm.{{Structname}}DB
	if err := db.First(&{{structname}}DB, c.Param("id")).Error; err != nil {
		var returnError GenericError
		returnError.Body.Code = http.StatusBadRequest
		returnError.Body.Message = err.Error()
		c.JSON(http.StatusBadRequest, returnError.Body)
		return
	}

	// with gorm.Model field, default delete is a soft delete. Unscoped() force delete
	db.Unscoped().Delete(&{{structname}}DB)

	c.JSON(http.StatusOK, gin.H{"data": true})
}

{{AssociationControllers}}
`

// GenControlers generates the setup file for the gorm
// return the registration calls
func GenControlers(db *gorm.DB) string {

	controllersCodeReg := ""

	// create the list of structs
	var structs []models.Struct
	db.Find(&structs)

	for _, _struct := range structs {
		filename := filepath.Join(ControllersPkgGenPath, fmt.Sprintf("%s.go", _struct.Name))

		// we should use go generate
		log.Println("generating controller file : " + filename)

		f, err := os.Create(filename)
		if err != nil {
			log.Panic(err)
		}

		lowerCaseStructName := strings.ToLower(_struct.Name)

		res := strings.ReplaceAll(controlerTemplate, "{{Structname}}", _struct.Name)
		res = strings.ReplaceAll(res, "{{structname}}", lowerCaseStructName)

		controllersCode, controllersCodeID, _controllersCodeReg := genControllersAssociation(db, _struct)

		controllersCodeReg += _controllersCodeReg

		res = strings.ReplaceAll(res, "{{AssociationControllers}}", controllersCode)
		res = strings.ReplaceAll(res, "{{AssociationControllerIDs}}", controllersCodeID)
		res = strings.ReplaceAll(res, "{{PkgPathRoot}}", strings.ReplaceAll(PkgGoPath, "/models", ""))

		fmt.Fprintf(f, "%s", res)

		defer f.Close()

	}
	return controllersCodeReg
}
