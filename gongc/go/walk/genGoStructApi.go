package walk

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gongc/go/models"
)

const structApiTemplate = `// generated by genGoStructApi.go
package api

import (
	"errors"

	"{{PkgPathRoot}}/models"
)

// {{Structname}}API is the twin in the "api" namespace of {{Structname}} of the "models" namespace
//
// swagger:model {{Structname}}API
type {{Structname}}API struct {
	models.{{Structname}}

	IDAPI uint // unique ID of the instance in the "api" namespace
{{InsertionPoint_PointerFieldAPI_Declaration}}{{InsertionPoint_ReversePointerFieldAPI_Declaration}}}

// CreateAPI{{Structname}} creates from {{structname}} an instance in the "api" namespace
// CreateAPI{{Structname}} performs a deep copy of {{structname}} fields
func (aPIGate *APIGateStruct) CreateAPI{{Structname}}({{structname}} *models.{{Structname}}) (IDAPI uint, err error) {

	{{structname}}API := new({{Structname}}API)

	IDAPI = aPIGate.last{{Structname}}APIID + 1
	aPIGate.last{{Structname}}APIID = IDAPI

	// update store
	aPIGate.Map{{Structname}}IDAPI[{{structname}}] = IDAPI
	aPIGate.MapIDAPI{{Structname}}[IDAPI] = {{structname}}
	aPIGate.Map{{Structname}}APIIDAPI[{{structname}}API] = IDAPI
	aPIGate.MapIDAPI{{Structname}}API[IDAPI] = {{structname}}API
	return
}

// UpdateAPI{{Structname}} updates from {{structname}} an instance in the "api" namespace
// UpdateAPI{{Structname}} performs a deep copy of {{structname}} fields
func (aPIGate *APIGateStruct) UpdateAPI{{Structname}}({{structname}} *models.{{Structname}}) (IDAPI uint, err error) {

	// check if twin ID exists
	var ok bool
	IDAPI, ok = aPIGate.Map{{Structname}}IDAPI[{{structname}}]
	if !ok {
		return uint(0), errors.New("unknown {{structname}}")
	}

	// get the twin API
	{{structname}}API := aPIGate.MapIDAPI{{Structname}}API[IDAPI]

	// update values of {{structname}}API with a deep copy
	{{structname}}API.{{Structname}} = *{{structname}}
{{InsertionPoint_PointerFieldAPI_Computation}}{{InsertionPoint_ReversePointerFieldAPI_Computation}}
	return
}
`

const AssociatonPointerFieldDeclarationTemplate = `
	// ID generated for the implementation of the field {{Structname}}{}.{{Fieldname}} *{{AssocStructName}}
	{{Fieldname}}IDAPI uint
`

const AssociatonReversePointerFieldDeclarationTemplate = `
	// ID generated for the implementation of the field {{Structname}}{}.{{Fieldname}} []*{{AssocStructName}}
	{{AssocStructName}}_{{Fieldname}}IDAPI uint
`

const AssociationPointerFieldComputationTemplate = `
	// set {{Fieldname}}ID
	if {{structname}}.{{Fieldname}} != nil {
		if {{fieldname}}IDAPI, ok := aPIGate.Map{{AssocStructName}}IDAPI[{{structname}}.{{Fieldname}}]; ok {
			{{structname}}API.{{Fieldname}}IDAPI = {{fieldname}}IDAPI
		} else {
			return 0, errors.New("{{Structname}} : Unkown {{AssocStructName}} with association {{Fieldname}}")
		}
	}
`

const AssociationReversePointerFieldComputationTemplate = `
	// set {{Fieldname}}IDs reverse pointer to {{AssocStructName}}
	for _, _{{assocStructName}} := range {{structname}}.{{Fieldname}} {
		if _IDAPI, ok := aPIGate.Map{{AssocStructName}}IDAPI[_{{assocStructName}}]; ok {
			if {{assocStructName}}API, ok := aPIGate.MapIDAPI{{AssocStructName}}API[_IDAPI]; ok {
				{{assocStructName}}API.Aclass_{{Fieldname}}IDAPI = IDAPI
			} else {
				return 0, errors.New("Aclass : Problem with {{AssocStructName}} with association {{Fieldname}}")
			}
		} else {
			return 0, errors.New("Aclass : Unkown {{AssocStructName}} with association {{Fieldname}}")
		}
	}
`

// GenGoStructApi ...
func GenGoStructApi(db *gorm.DB) {

	// general working variable
	var insertions string

	// create the list of structs
	var structs []models.Struct
	db.Find(&structs)

	for _, _struct := range structs {
		filename := filepath.Join(ApiPkgGenPath, fmt.Sprintf("%sAPI.go", _struct.Name))

		// we should use go generate
		log.Println("generating api file : " + filename)

		f, err := os.Create(filename)
		if err != nil {
			log.Panic(err)
		}

		lowerCaseStructName := strings.ToLower(_struct.Name)

		res := structApiTemplate

		// get fields of struct and generate an ID relationship for every
		// pointer or array
		var fields models.Fields
		query := db.Model(&_struct).Related(&fields)
		if query.Error != nil {
			log.Fatal(query.Error.Error())
			return
		}
		sort.Slice(fields, func(i, j int) bool {
			return fields[i].Name < fields[j].Name
		})

		insertions = ""
		for _, field := range fields {

			if field.Kind == reflect.Ptr && field.AssociatedStructID != 0 {

				// fetch the assoc struct
				var assocStruct models.Struct
				db.First(&assocStruct, field.StructID)

				insertions += replace4(AssociatonPointerFieldDeclarationTemplate,
					"{{Fieldname}}", field.Name,
					"{{fieldname}}", strings.ToLower(field.Name),
					"{{AssocStructName}}", assocStruct.Name,
					"{{assocStructName}}", strings.ToLower(assocStruct.Name))
			}
		}
		res = strings.ReplaceAll(res, "{{InsertionPoint_PointerFieldAPI_Declaration}}", insertions)

		insertions = ""
		for _, field := range fields {

			if field.Kind == reflect.Ptr && field.AssociatedStructID != 0 {

				insertions += replace4(AssociationPointerFieldComputationTemplate,
					"{{Fieldname}}", field.Name,
					"{{fieldname}}", strings.ToLower(field.Name),
					"{{AssocStructName}}", field.AssociatedStructName,
					"{{assocStructName}}", strings.ToLower(field.AssociatedStructName))
			}
		}
		res = strings.ReplaceAll(res, "{{InsertionPoint_PointerFieldAPI_Computation}}", insertions)

		insertions = ""
		for _, field := range fields {

			if field.Kind == reflect.Slice && field.AssociatedStructID != 0 {

				insertions += replace4(AssociationReversePointerFieldComputationTemplate,
					"{{Fieldname}}", field.Name,
					"{{fieldname}}", strings.ToLower(field.Name),
					"{{AssocStructName}}", field.AssociatedStructName,
					"{{assocStructName}}", strings.ToLower(field.AssociatedStructName))
			}
		}
		res = strings.ReplaceAll(res, "{{InsertionPoint_ReversePointerFieldAPI_Computation}}", insertions)

		// generates reverse IDs for slice of pointer to the current struct
		// fetch all association fields worthy of a assocation path
		// ie. where the AssociatedStructID is the struct of interest
		insertions = ""
		var fieldWhichPointsToStruct models.Field
		fieldWhichPointsToStruct.AssociatedStructID = _struct.ID
		if queryAssoc := db.Where(&fieldWhichPointsToStruct).Find(&fields); queryAssoc.Error != nil {
			log.Fatal(queryAssoc.Error.Error())
		}
		for _, field := range fields {

			if field.Kind == reflect.Slice && field.AssociatedStructID != 0 {

				insertions += replace2(AssociatonReversePointerFieldDeclarationTemplate,
					"{{AssocStructName}}", field.StructName,
					"{{Fieldname}}", field.Name)
			}
		}
		res = strings.ReplaceAll(res, "{{InsertionPoint_ReversePointerFieldAPI_Declaration}}", insertions)

		res = replace2(res, "{{Structname}}", _struct.Name, "{{structname}}", lowerCaseStructName)
		res = strings.ReplaceAll(res, "{{PkgPathRoot}}", strings.ReplaceAll(PkgGoPath, "/models", ""))

		fmt.Fprint(f, res)
		defer f.Close()
	}
}
