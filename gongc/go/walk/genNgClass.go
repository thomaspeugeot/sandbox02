package walk

import (
	"fmt"
	"log"
	"reflect"
	"sort"
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gongc/go/models"
)

const templateNgClass = ` // generated by GenNgClass.go
export class {{Structname}} {
{{insertionForFields}}
}
`
const templateNgClassDB = ` // generated by GenNgClass.go
{{ImportsForSliceDB}}
export class {{Structname}}DB {
	CreatedAt?: string;
	DeletedAt?: string;
	ID?: number;

{{insertionForFields}}
{{DeclarationsForSliceDB}}
}
`

const templateNgClassAPI = ` // generated by GenNgClass.go
export class {{Structname}}API {

{{insertionForFields}}
}
`

const templateNgClassField = `	{{FieldName}}?: {{TypeInput}}
`
const templateNgImportForPointerOrSliceDB = `
import { {{AssocStructName}}DB} from './{{assocStructName}}-db'
`

const ngTemplateReversePointerToArray = `
	// ID generated for the implementation of the field {{Structname}}{}.{{Fieldname}} []*{{AssociationStructName}}
	{{AssociationStructName}}_{{Fieldname}}DBID?: number
`

// GenNgClass generates the Ng Class
func GenNgClass(db *gorm.DB) {

	// create the list of structs
	var structs []models.Struct
	db.Find(&structs)

	// generates one detail compenent per struct
	for _, _struct := range structs {

		structName := strings.ToLower(_struct.Name)

		// get fields
		var fields models.Fields
		if query := db.Model(&_struct).Related(&fields); query.Error != nil {
			log.Fatal(query.Error.Error())
		}
		sort.Slice(fields, func(i, j int) bool {
			return fields[i].Name < fields[j].Name
		})

		res := ""
		ImportsForPointerOrSliceDB := ""
		DeclarationsForSliceDB := ""

		// TODO when multiple field have the same association struct
		assocStructMatch := make(map[uint]bool)
		for _, field := range fields {

			if field.Kind != reflect.Ptr && field.Kind != reflect.Slice &&
				(field.Kind == reflect.Int || field.Kind == reflect.Float64 || field.Kind == reflect.String) {

				// conversion form go type to ts type
				typeOfField := "string"
				if field.Kind == reflect.Int || field.Kind == reflect.Float64 {
					typeOfField = "number"
				}

				res += replace2(templateNgClassField, "{{FieldName}}", field.Name, "{{TypeInput}}", typeOfField)
			}

			if field.Kind == reflect.Ptr && field.AssociatedStructName == "*bool" {
				res += replace2(templateNgClassField, "{{FieldName}}", field.Name, "{{TypeInput}}", "boolean")
			}

			if field.Kind == reflect.Slice && field.AssociatedStructID != 0 && field.AssociatedStructID != _struct.ID {
				DeclarationsForSliceDB += "\n"
				if assocStructMatch[field.AssociatedStructID] == false {
					assocStructMatch[field.AssociatedStructID] = true
					ImportsForPointerOrSliceDB += replace2(templateNgImportForPointerOrSliceDB,
						"{{AssocStructName}}", field.AssociatedStructName,
						"{{assocStructName}}", strings.ToLower(field.AssociatedStructName))

				}
				DeclarationsForSliceDB += replace2(templateNgClassField, "{{FieldName}}",
					field.Name, "{{TypeInput}}", "Array<"+field.AssociatedStructName+"DB>")
			}

			if field.Kind == reflect.Ptr && field.AssociatedStructID != 0 && field.AssociatedStructID != _struct.ID {
				DeclarationsForSliceDB += "\n"

				if assocStructMatch[field.AssociatedStructID] == false {
					assocStructMatch[field.AssociatedStructID] = true
					ImportsForPointerOrSliceDB += replace2(templateNgImportForPointerOrSliceDB,
						"{{AssocStructName}}", field.AssociatedStructName,
						"{{assocStructName}}", strings.ToLower(field.AssociatedStructName))

				}
				DeclarationsForSliceDB += replace2(templateNgClassField, "{{FieldName}}", field.Name,
					"{{TypeInput}}", field.AssociatedStructName+"DB")
				DeclarationsForSliceDB += replace2(templateNgClassField, "{{FieldName}}", field.Name+"ID", "{{TypeInput}}", "number")
				DeclarationsForSliceDB += replace2(templateNgClassField, "{{FieldName}}", field.Name+"Name", "{{TypeInput}}", "string")
			}

			if field.Kind == reflect.Struct && field.AssociatedStructName == "time.Time" {

				res += replace2(templateNgClassField, "{{FieldName}}", field.Name, "{{TypeInput}}", "string")
			}

		}

		// generates reverse IDs for slice of pointer to the current struct
		// fetch all association fields worthy of a assocation path
		// ie. where the AssociatedStructID is the struct of interest
		var fieldWhichPointsToStruct models.Field
		fieldWhichPointsToStruct.AssociatedStructID = _struct.ID
		if queryAssoc := db.Where(&fieldWhichPointsToStruct).Find(&fields); queryAssoc.Error != nil {
			log.Fatal(queryAssoc.Error.Error())
		}
		for _, field := range fields {

			if field.Kind == reflect.Slice && field.AssociatedStructID != 0 {

				DeclarationsForSliceDB += replace2(ngTemplateReversePointerToArray,
					"{{AssociationStructName}}", field.StructName,
					"{{Fieldname}}", field.Name)
			}
		}

		stringTS := templateNgClass
		stringTS = strings.ReplaceAll(stringTS, "{{insertionForFields}}", res)
		stringTS = strings.ReplaceAll(stringTS, "{{Structname}}", _struct.Name)
		file := createSingleFileInNgTargetPath(fmt.Sprintf("%s.ts", structName))
		defer file.Close()
		fmt.Fprint(file, stringTS)

		stringTS = templateNgClassAPI
		stringTS = strings.ReplaceAll(stringTS, "{{insertionForFields}}", res)
		stringTS = strings.ReplaceAll(stringTS, "{{Structname}}", _struct.Name)
		file = createSingleFileInNgTargetPath(fmt.Sprintf("%s-api.ts", structName))
		defer file.Close()
		fmt.Fprint(file, stringTS)

		stringTS = templateNgClassDB
		stringTS = strings.ReplaceAll(stringTS, "{{ImportsForSliceDB}}", ImportsForPointerOrSliceDB)
		stringTS = strings.ReplaceAll(stringTS, "{{DeclarationsForSliceDB}}", DeclarationsForSliceDB)
		stringTS = strings.ReplaceAll(stringTS, "{{insertionForFields}}", res)
		stringTS = strings.ReplaceAll(stringTS, "{{Structname}}", _struct.Name)
		file = createSingleFileInNgTargetPath(fmt.Sprintf("%s-db.ts", structName))
		defer file.Close()
		fmt.Fprint(file, stringTS)
	}
}
