package walk

import (
	"fmt"
	"log"
	"reflect"
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gongc/go/models"
)

const templateNgService = ` // generated by GenNgService.go
import { Injectable } from '@angular/core';
import { HttpClientModule } from '@angular/common/http';
import { HttpClient, HttpHeaders } from '@angular/common/http';

/*
 * Kamar : Ajout d'un moyen pour communiquer entre les composants qui partagent de l'information
 * afin qu'ils soient notifiés d'un changement.
 */
import { BehaviorSubject } from 'rxjs';
import { Observable, of } from 'rxjs';
import { catchError, map, tap } from 'rxjs/operators';

import { {{Structname}}API } from './{{structname}}-api';
import { {{Structname}}DB } from './{{structname}}-db';

{{ImportsOfStructWithPointerFieldToCurrentStruct}}

@Injectable({
  providedIn: 'root'
})
export class {{Structname}}Service {

  httpOptions = {
    headers: new HttpHeaders({ 'Content-Type': 'application/json' })
  };

  // Kamar Raïmo: Adding a way to communicate between components that share information
  // so that they are notified of a change.
  {{Structname}}ServiceChanged: BehaviorSubject<string> = new BehaviorSubject("");

  private {{structname}}sUrl = 'http://{{addr}}/{{structname}}s';

  constructor(
    private http: HttpClient
  ) { }

  /** GET {{structname}}s from the server */
  get{{Structname}}s(): Observable<{{Structname}}DB[]> {
    return this.http.get<{{Structname}}DB[]>(this.{{structname}}sUrl)
      .pipe(
        tap(_ => this.log('fetched {{structname}}s')),
        catchError(this.handleError<{{Structname}}DB[]>('get{{Structname}}s', []))
      );
  }

  /** GET {{structname}} by id. Will 404 if id not found */
  get{{Structname}}(id: number): Observable<{{Structname}}DB> {
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;
    return this.http.get<{{Structname}}DB>(url).pipe(
      tap(_ => this.log(` + "`" + `fetched {{structname}} id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>(` + "`" + `get{{Structname}} id=${id}` + "`" + `))
    );
  }

  //////// Save methods //////////

  /** POST: add a new {{structname}} to the server */
  post{{Structname}}({{structname}}API: {{Structname}}API): Observable<{{Structname}}DB> {
    return this.http.post<{{Structname}}DB>(this.{{structname}}sUrl, {{structname}}API, this.httpOptions).pipe(
      tap((new{{Structname}}: {{Structname}}DB) => this.log(` + "`" + `added {{structname}} w/ id=${new{{Structname}}.ID}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>('add{{Structname}}'))
    );
  }

  /** DELETE: delete the {{structname}}db from the server */
  delete{{Structname}}({{structname}}db: {{Structname}}DB | number): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    return this.http.delete<{{Structname}}DB>(url, this.httpOptions).pipe(
      tap(_ => this.log(` + "`" + `deleted {{structname}}db id=${id}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>('delete{{Structname}}'))
    );
  }

  /** PUT: update the {{structname}}db on the server */
  update{{Structname}}({{structname}}db: {{Structname}}DB): Observable<{{Structname}}DB> {
    const id = typeof {{structname}}db === 'number' ? {{structname}}db : {{structname}}db.ID;
    const url = ` + "`" + `${this.{{structname}}sUrl}/${id}` + "`" + `;

    return this.http.put(url, {{structname}}db, this.httpOptions).pipe(
      tap(_ => this.log(` + "`" + `updated {{structname}}db id=${{{structname}}db.ID}` + "`" + `)),
      catchError(this.handleError<{{Structname}}DB>('update{{Structname}}'))
    );
  }

{{GettersOfStructWithPointerFieldToCurrentStruct}}

  /**
   * Handle Http operation that failed.
   * Let the app continue.
   * @param operation - name of the operation that failed
   * @param result - optional value to return as the observable result
   */
  private handleError<T>(operation = 'operation', result?: T) {
    return (error: any): Observable<T> => {

      // TODO: send the error to remote logging infrastructure
      console.error(error); // log to console instead

      // TODO: better job of transforming error for user consumption
      this.log(` + "`" + `${operation} failed: ${error.message}` + "`" + `);

      // Let the app keep running by returning an empty result.
      return of(result as T);
    };
  }

  private log(message: string) {

  }
}
`
const ngTemplateForImportOfStructWithPointerFieldToCurrentStruct = `
// import of struct with pointer field to current struct
import { {{AssocStructName}}DB} from './{{assocStructName}}-db'`

const ngTemplateForViaGetterOfStructWithPointerFieldToCurrentStruct = `
    // getter of struct with pointer to current struct
    get{{Structname}}{{AssocStructName}}sVia{{Fieldname}}(id: number): Observable<Array<{{AssocStructName}}DB>> {
      const url = ` + "`" + `${this.{{structname}}sUrl}/${id}/{{assocStructName}}svia{{fieldname}}` + "`" + `;
      return this.http.get<Array<{{AssocStructName}}DB>>(url).pipe(
        tap(_ => this.log(` + "`" + `fetched {{structname}} id=${id}` + "`" + `)),
        catchError(this.handleError<Array<{{AssocStructName}}DB>>(` + "`" + `get{{Structname}} id=${id}` + "`" + `))
      );
    }
`

// GenNgService generates the Ng Class
func GenNgService(db *gorm.DB) {

	// create the list of structs
	var structs []models.Struct
	db.Find(&structs)

	// generates one detail compenent per struct
	for _, _struct := range structs {

		structName := strings.ToLower(_struct.Name)

		var fields models.Fields

		// fetch all association fields worthy of a assocation path
		// ie. where the AssociatedStructID is the struct of interest

		columnName := gorm.ToColumnName("AssociatedStructID")
		// log.Output(0, fmt.Sprintf("Column name: %s", columnName))
		queryAssoc := db.Where(fmt.Sprintf("%s = ?", columnName), _struct.ID).Find(&fields)
		if queryAssoc.Error != nil {
			log.Fatal(queryAssoc.Error.Error())
		}

		// question : do you like variables with long name ?
		// answer : when the problem is complex ( elts to deal with)
		ImportsOfStructWithPointerFieldToCurrentStruct := ""
		GettersOfStructWithPointerFieldToCurrentStruct := ""

		// TODO when multiple field have the same association struct
		assocStructMatch := make(map[uint]bool)
		for _, field := range fields {

			if field.Kind == reflect.Ptr {
				// fetch the assoc struct
				var assocStruct models.Struct
				db.First(&assocStruct, field.StructID)
				lowerCaseAssocStructName := strings.ToLower(assocStruct.Name)
				lowerCaseFieldname := strings.ToLower(field.Name)

				// avoid multiple imports
				_, ok := assocStructMatch[field.StructID]
				if !ok && (assocStruct.ID != _struct.ID) {
					assocStructMatch[field.StructID] = true

					importStringTS := ngTemplateForImportOfStructWithPointerFieldToCurrentStruct

					// for imports
					importStringTS = strings.ReplaceAll(importStringTS, "{{AssocStructName}}", assocStruct.Name)
					importStringTS = strings.ReplaceAll(importStringTS, "{{assocStructName}}", lowerCaseAssocStructName)
					ImportsOfStructWithPointerFieldToCurrentStruct += importStringTS
				}
				getterStringTS := ngTemplateForViaGetterOfStructWithPointerFieldToCurrentStruct

				// for getters
				getterStringTS = strings.ReplaceAll(getterStringTS, "{{AssocStructName}}", assocStruct.Name)
				getterStringTS = strings.ReplaceAll(getterStringTS, "{{assocStructName}}", lowerCaseAssocStructName)
				getterStringTS = strings.ReplaceAll(getterStringTS, "{{Fieldname}}", field.Name)
				getterStringTS = strings.ReplaceAll(getterStringTS, "{{fieldname}}", lowerCaseFieldname)
				GettersOfStructWithPointerFieldToCurrentStruct += getterStringTS
			}

		}

		stringTS := templateNgService

		stringTS = strings.ReplaceAll(stringTS,
			"{{ImportsOfStructWithPointerFieldToCurrentStruct}}",
			ImportsOfStructWithPointerFieldToCurrentStruct)
		stringTS = strings.ReplaceAll(stringTS,
			"{{GettersOfStructWithPointerFieldToCurrentStruct}}",
			GettersOfStructWithPointerFieldToCurrentStruct)
		stringTS = strings.ReplaceAll(stringTS, "{{Structname}}", _struct.Name)
		stringTS = strings.ReplaceAll(stringTS, "{{structname}}", structName)
		stringTS = strings.ReplaceAll(stringTS, "{{addr}}", ADDR)
		file := createSingleFileInNgTargetPath(fmt.Sprintf("%s.service.ts", structName))
		defer file.Close()
		fmt.Fprint(file, stringTS)
	}
}
