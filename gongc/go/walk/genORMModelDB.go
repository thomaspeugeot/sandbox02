package walk

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gongc/go/models"
)

const modelDBTemplate = `// generated by genORMModelDB.go
package orm

import (
	{{LoadersImports}}
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"{{PkgPathRoot}}/models"
)

// {{Structname}}API is the input in POST API
// 
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model {{structname}}API
type {{Structname}}API struct {

	models.{{Structname}}

	// association fields
	{{AssociationFields}}
}

// {{Structname}}DB describes a {{structname}} in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model {{structname}}DB
type {{Structname}}DB struct {
	gorm.Model

	{{Structname}}API
}

// {{Structname}}DBs arrays {{structname}}DBs
// swagger:response {{structname}}DBsResponse
type {{Structname}}DBs []{{Structname}}DB

// {{Structname}}DBResponse provides response
// swagger:response {{structname}}DBResponse
type {{Structname}}DBResponse struct {
	{{Structname}}DB
}
`

const loaderImports = `"log"
	"sort"
`

const loaderTemplate = `
type {{Structname}}Map map[string]*models.{{Structname}}


// MemoryToDB{{Structname}} load the map into the DB
func MemoryToDB{{Structname}}({{structname}}s {{Structname}}Map, db *gorm.DB) {
	fmt.Println("Load DB - {{Structname}}s")

	// sort {{structname}}s
	{{structname}}sSorted := make([]string, 0, len({{structname}}s))
	for k := range {{structname}}s {
		{{structname}}sSorted = append({{structname}}sSorted, k)
	}
	sort.Strings({{structname}}sSorted)
	for _, nom := range {{structname}}sSorted {
		{{structname}} := {{structname}}s[nom]

		var {{structname}}DB {{Structname}}DB
		{{structname}}DB.{{Structname}} = *{{structname}}

{{AssociationLoaders}}

		query := db.Create(&{{structname}}DB)
		if query.Error != nil {
			log.Fatal("load")
		}
	}
}
`

const associationLoaderTemplate = `	
		// initiate association in DB
		if {{structname}}.{{Fieldname}} != nil {

			// fetch the id of the {{fieldname}}
			var {{associationStructName}}DB {{AssociationStructName}}DB
			columnName := gorm.ToColumnName("Name")
			query := db.Where(genQuery(columnName), {{structname}}.{{Fieldname}}.Name).Find(&{{associationStructName}}DB)

			if query.Error != nil {
				log.Panic(query.Error.Error())
			}

			// set the association
			{{structname}}DB.{{Fieldname}}ID = &{{associationStructName}}DB.ID
			{{structname}}DB.{{Fieldname}}Name = {{associationStructName}}DB.Name
		}
`

const translationTemplate = `
// ModelToORM{{Structname}}Translate is a translation function from models object to ORM objects
func ModelToORM{{Structname}}Translate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that {{structname}}Store is nil as well as {{structname}}DBs
		if map_{{Structname}}DBID_{{Structname}}Ptr != nil {
			err := errors.New("In CreateMode translation, map_{{Structname}}DBID_{{Structname}}Ptr should be nil")
			return err
		}

		if map_{{Structname}}DBID_{{Structname}}DB != nil {
			err := errors.New("In CreateMode translation, map_{{Structname}}DBID_{{Structname}}DB should be nil")
			return err
		}

		if map_{{Structname}}Ptr_{{Structname}}DBID != nil {
			err := errors.New("In CreateMode translation, map_{{Structname}}Ptr_{{Structname}}DBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.{{Structname}}, 0)
		map_{{Structname}}DBID_{{Structname}}Ptr = &tmp

		tmpDB := make(map[uint]*{{Structname}}DB, 0)
		map_{{Structname}}DBID_{{Structname}}DB = &tmpDB

		tmpID := make(map[*models.{{Structname}}]uint, 0)
		map_{{Structname}}Ptr_{{Structname}}DBID = &tmpID

		for _, {{structname}} := range models.AllModelStore.{{Structname}}s {

			// initiate {{structname}}
			var {{structname}}DB {{Structname}}DB
			{{structname}}DB.{{Structname}} = *{{structname}}

			query := db.Create(&{{structname}}DB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}] = {{structname}}DB.ID
			(*map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID] = {{structname}}
			(*map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DB.ID] = &{{structname}}DB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that {{structname}}Store is not nil
		if map_{{Structname}}DBID_{{Structname}}Ptr == nil {
			err := errors.New("In UpdateMode translation, {{structname}}Store should not be nil")
			return err
		}

		if map_{{Structname}}DBID_{{Structname}}DB == nil {
			err := errors.New("In UpdateMode translation, {{structname}}Store should not be nil")
			return err
		}

		// update fields of {{structname}}DB with fields of {{structname}}
		for _, {{structname}} := range models.AllModelStore.{{Structname}}s {
			{{structname}}DBID := (*map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]
			{{structname}}DB := (*map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DBID]

			{{structname}}DB.{{Structname}} = *{{structname}}
		}

		// parse model objects ot update associations
		for idx, {{structname}} := range *map_{{Structname}}DBID_{{Structname}}Ptr {

			// fetch matching {{structname}}DB
			if {{structname}}DB, ok := (*map_{{Structname}}DBID_{{Structname}}DB)[idx]; ok {
				// set {{Fieldname}}ID
{{InsertionPointForPointerFieldIDUpdates}}
{{InsertionForModelToORMReversePointerSetup}}

				query := db.Save(&{{structname}}DB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, {{structname}}Store should not be nil %v %v",
						{{structname}}DB, {{structname}}))
				return err
			}
		}
	}
	return nil
}

// stores {{Structname}}DB according to their gorm ID
var map_{{Structname}}DBID_{{Structname}}DB *map[uint]*{{Structname}}DB

// stores {{Structname}}DB ID according to {{Structname}} address
var map_{{Structname}}Ptr_{{Structname}}DBID *map[*models.{{Structname}}]uint

// stores {{Structname}} according to their gorm ID
var map_{{Structname}}DBID_{{Structname}}Ptr *map[uint]*models.{{Structname}}

// ORMToModel{{Structname}}Translate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModel{{Structname}}Translate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that {{structname}}Stores are nil

		if map_{{Structname}}DBID_{{Structname}}Ptr != nil {
			err := errors.New("In CreateMode translation, Parameters {{structname}}Store should be nil")
			return err
		}

		if map_{{Structname}}DBID_{{Structname}}DB != nil {
			err := errors.New("In CreateMode translation, parameters {{Structname}}DBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.{{Structname}}, 0)
		map_{{Structname}}DBID_{{Structname}}Ptr = &tmp

		tmpDB := make(map[uint]*{{Structname}}DB, 0)
		map_{{Structname}}DBID_{{Structname}}DB = &tmpDB

		tmpID := make(map[*models.{{Structname}}]uint, 0)
		map_{{Structname}}Ptr_{{Structname}}DBID = &tmpID

		models.AllModelStore.{{Structname}}s = make([]*models.{{Structname}}, 0)

		{{structname}}DBArray := make([]{{Structname}}DB, 0)
		query := db.Find(&{{structname}}DBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, {{structname}}DB := range {{structname}}DBArray {

			// create entries in the tree maps.
			{{structname}} := {{structname}}DB.{{Structname}}
			(*map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID] = &{{structname}}

			(*map_{{Structname}}Ptr_{{Structname}}DBID)[&{{structname}}] = {{structname}}DB.ID

			{{structname}}DBCopy := {{structname}}DB
			(*map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DB.ID] = &{{structname}}DBCopy

			// append model store with the new element
			models.AllModelStore.{{Structname}}s = append(models.AllModelStore.{{Structname}}s, &{{structname}})
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that {{structname}}Store is not nil
		if map_{{Structname}}DBID_{{Structname}}Ptr == nil {
			err := errors.New("In UpdateMode translation, {{structname}}Store should not be nil")
			return err
		}

		if map_{{Structname}}DBID_{{Structname}}DB == nil {
			err := errors.New("In UpdateMode translation, {{structname}}Store should not be nil")
			return err
		}

		// update fields of {{structname}}DB with fields of {{structname}}
		for _, {{structname}} := range models.AllModelStore.{{Structname}}s {
			{{structname}}DBID := (*map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]
			{{structname}}DB := (*map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DBID]

			*{{structname}} = {{structname}}DB.{{Structname}}
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, {{structname}}DB := range *map_{{Structname}}DBID_{{Structname}}DB {
			{{structname}} := (*map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID]
			if {{structname}} == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}

{{InsertionPointForPointerFieldsUpdates}}
{{InsertionForORMToModelArrayOfPointersRedeem}}

		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORM{{Structname}}({{structname}} *models.{{Structname}}) {

	CreateORM{{Structname}}(allORMStoreStruct.db, {{structname}})
}

// CreateORM{{Structname}} creates ORM{{Strucname}} in DB from {{structname}}
func CreateORM{{Structname}}(
	db *gorm.DB,
	{{structname}} *models.{{Structname}}) (Error error) {

	// initiate {{structname}}
	var {{structname}}DB {{Structname}}DB
	{{structname}}DB.{{Structname}} = *{{structname}}

	query := db.Create(&{{structname}}DB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}] = {{structname}}DB.ID
	(*map_{{Structname}}DBID_{{Structname}}Ptr)[{{structname}}DB.ID] = {{structname}}
	(*map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DB.ID] = &{{structname}}DB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORM{{Structname}}({{structname}} *models.{{Structname}}) {

	DeleteORM{{Structname}}(allORMStoreStruct.db, {{structname}})
}


func DeleteORM{{Structname}}(
	db *gorm.DB,
	{{structname}} *models.{{Structname}}) (Error error) {

	{{structname}}DBID := (*map_{{Structname}}Ptr_{{Structname}}DBID)[{{structname}}]
	{{structname}}DB := (*map_{{Structname}}DBID_{{Structname}}DB)[{{structname}}DBID]

	query := db.Unscoped().Delete(&{{structname}}DB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_{{Structname}}Ptr_{{Structname}}DBID, {{structname}})
	delete(*map_{{Structname}}DBID_{{Structname}}Ptr, {{structname}}DB.ID)
	delete(*map_{{Structname}}DBID_{{Structname}}DB, {{structname}}DBID)

	return
}
`

const associationPointFieldUpdateTemplateGO = `
				// {{Fieldname}} field
				if {{structname}}DB.{{Fieldname}}ID != nil {
					{{structname}}.{{Fieldname}} = (*map_{{AssociationStructName}}DBID_{{AssociationStructName}}Ptr)[*({{structname}}DB.{{Fieldname}}ID)]
				}
`
const associationPointFieldIDUpdateTemplateGO = `
				// set {{Fieldname}}ID
				if {{structname}}.{{Fieldname}} != nil {
					if {{fieldname}}Id, ok := (*map_{{AssociationStructName}}Ptr_{{AssociationStructName}}DBID)[{{structname}}.{{Fieldname}}]; ok {
						{{structname}}DB.{{Fieldname}}ID = &{{fieldname}}Id
					}
				}
`
const modelToORMTemplatePointerOfArray = `
				// set {{Fieldname}}IDs reverse pointer to {{AssociationStructName}}
				for _, {{AssociationStructName}} := range {{structname}}.{{Fieldname}} {
					if {{AssociationStructName}}DBID, ok := (*map_{{AssociationStructName}}Ptr_{{AssociationStructName}}DBID)[{{AssociationStructName}}]; ok {
						if {{AssociationStructName}}DB, ok := (*map_{{AssociationStructName}}DBID_{{AssociationStructName}}DB)[{{AssociationStructName}}DBID]; ok {
							{{AssociationStructName}}DB.{{Structname}}_{{Fieldname}}DBID = {{structname}}DB.ID
							if q := db.Save(&{{AssociationStructName}}DB); q.Error != nil {
								return q.Error
							}
						}
					}
				}
`

const ORMToModelTemplatePointerOfArray = `
				// parse all {{AssociationStructName}}DB and redeem the array of poiners to {{Structname}}
				for _, {{AssociationStructName}}DB := range *map_{{AssociationStructName}}DBID_{{AssociationStructName}}DB {
					if {{AssociationStructName}}DB.{{Structname}}_{{Fieldname}}DBID == {{structname}}DB.ID {
						{{AssociationStructName}} := (*map_{{AssociationStructName}}DBID_{{AssociationStructName}}Ptr)[{{AssociationStructName}}DB.ID]
						{{structname}}.{{Fieldname}} = append({{structname}}.{{Fieldname}}, {{AssociationStructName}})
					}
				}
`

const declatationReversePointerToArray = `
	// ID generated for the implementation of the field {{Structname}}{}.{{Fieldname}} []*{{AssociationStructName}}
	{{AssociationStructName}}_{{Fieldname}}DBID uint
`

// GenORMModelDB generates the setup file for the gorm
func GenORMModelDB(db *gorm.DB, loaders bool) {

	// create the list of structs
	var structs []models.Struct
	db.Find(&structs)

	for _, _struct := range structs {
		filename := filepath.Join(OrmPkgGenPath, fmt.Sprintf("%sDB.go", _struct.Name))

		// we should use go generate
		log.Println("generating DB file : " + filename)

		f, err := os.Create(filename)
		if err != nil {
			log.Panic(err)
		}

		lowerCaseStructName := strings.ToLower(_struct.Name)

		res := strings.ReplaceAll(modelDBTemplate, "{{Structname}}", _struct.Name)
		res = strings.ReplaceAll(res, "{{structname}}", lowerCaseStructName)

		if loaders {
			res = strings.ReplaceAll(res, "{{LoadersImports}}", loaderImports)
		} else {
			res = strings.ReplaceAll(res, "{{LoadersImports}}", "")
		}

		// get fields of struct and generate an ID relationship for every
		// pointer or array
		var fields models.Fields
		query := db.Model(&_struct).Related(&fields)
		if query.Error != nil {
			log.Fatal(query.Error.Error())
			return
		}
		sort.Slice(fields, func(i, j int) bool {
			return fields[i].Name < fields[j].Name
		})

		fieldsDeclaration := ""
		for _, field := range fields {

			if field.Kind == reflect.Ptr && field.AssociatedStructID != 0 {
				fieldsDeclaration += "\n"
				fieldsDeclaration += "\t// field " + field.Name + " is a pointer to another Struct (optional or 0..1)\n"
				fieldsDeclaration += "\t// This field is generated into another field to enable a GORM `HAS ONE` association\n"
				fieldsDeclaration += "\t" + field.Name + "ID *uint\n"

				// generate a field for the name, if the Name field exists

				// check if associated struct has a "Name" Filed
				var nameAssocFields models.Fields

				var searchField models.Field
				searchField.Name = "Name"
				searchField.StructName = field.AssociatedStructName

				nameAssocFieldQuery := db.Where(&searchField).Find(&nameAssocFields)
				if nameAssocFieldQuery.Error == nil { // there is such a field
					fieldsDeclaration += "\n"
					fieldsDeclaration += "\t// the associated Struct has a Name field, therefore it is generated to compute views with this relation\n"
					fieldsDeclaration += "\t" + field.Name + "Name string\n"
				}
			}
		}

		// do the same for the oppo{{structname}} relation of a pointer (the HasMany relation)
		// we need to find the oppo{{structname}} struct
		columnName := gorm.ToColumnName("AssociatedStructID")

		var inverseAssocFields models.Fields
		queryAssoc := db.Where(fmt.Sprintf("%s = ?", columnName), _struct.ID).Find(&inverseAssocFields)
		if queryAssoc.Error != nil {
			log.Fatal(queryAssoc.Error.Error())
			return
		}

		for _, field := range inverseAssocFields {

			if field.Kind == reflect.Slice && field.AssociatedStructID != 0 {
				fieldsDeclaration +=
					replace3(declatationReversePointerToArray,
						"{{Structname}}", _struct.Name,
						"{{Fieldname}}", field.Name,
						"{{AssociationStructName}}", field.StructName)
			}
		}

		//
		log.Printf("struct %s, inverse fields %d", _struct.Name, len(inverseAssocFields))

		// TODO #12 investigate how to use generate the oppo{{structname}} relation slice
		// first version is not necessary

		res = strings.ReplaceAll(res, "{{AssociationFields}}", fieldsDeclaration)
		res = strings.ReplaceAll(res, "{{PkgPathRoot}}", strings.ReplaceAll(PkgGoPath, "/models", ""))

		fmt.Fprint(f, res)

		// add translations functions
		{
			pointerFieldInits := ""
			pointerFieldIDInits := ""

			modelToORMPointerOfArrayRedeem := ""
			ORMToModelPointerOfArrayRedeem := ""

			for _, field := range fields {

				if field.Kind == reflect.Ptr && field.AssociatedStructID != 0 {
					lowerCaseFieldName := strings.ToLower(field.Name)
					lowerCaseAssociationStructName := strings.ToLower(field.AssociatedStructName)

					res = associationPointFieldUpdateTemplateGO
					res = strings.ReplaceAll(res, "{{Fieldname}}", field.Name)
					res = strings.ReplaceAll(res, "{{fieldname}}", lowerCaseFieldName)
					res = strings.ReplaceAll(res, "{{AssociationStructName}}", field.AssociatedStructName)
					res = strings.ReplaceAll(res, "{{associationStructName}}", lowerCaseAssociationStructName)

					pointerFieldInits += res

					res2 := associationPointFieldIDUpdateTemplateGO
					res2 = strings.ReplaceAll(res2, "{{Fieldname}}", field.Name)
					res2 = strings.ReplaceAll(res2, "{{fieldname}}", lowerCaseFieldName)
					res2 = strings.ReplaceAll(res2, "{{AssociationStructName}}", field.AssociatedStructName)
					res2 = strings.ReplaceAll(res2, "{{associationStructName}}", lowerCaseAssociationStructName)

					pointerFieldIDInits += res2
				}

				if field.Kind == reflect.Slice && field.AssociatedStructID != 0 {
					lowerCaseFieldName := strings.ToLower(field.Name)
					lowerCaseAssociationStructName := strings.ToLower(field.AssociatedStructName)

					res = modelToORMTemplatePointerOfArray
					res = strings.ReplaceAll(res, "{{Fieldname}}", field.Name)
					res = strings.ReplaceAll(res, "{{fieldname}}", lowerCaseFieldName)
					res = strings.ReplaceAll(res, "{{AssociationStructName}}", field.AssociatedStructName)
					res = strings.ReplaceAll(res, "{{associationStructName}}", lowerCaseAssociationStructName)

					modelToORMPointerOfArrayRedeem += res

					res2 := ORMToModelTemplatePointerOfArray
					res2 = strings.ReplaceAll(res2, "{{Fieldname}}", field.Name)
					res2 = strings.ReplaceAll(res2, "{{fieldname}}", lowerCaseFieldName)
					res2 = strings.ReplaceAll(res2, "{{AssociationStructName}}", field.AssociatedStructName)
					res2 = strings.ReplaceAll(res2, "{{associationStructName}}", lowerCaseAssociationStructName)

					ORMToModelPointerOfArrayRedeem += res2
				}

			}
			res = translationTemplate
			res = strings.ReplaceAll(res, "{{InsertionPointForPointerFieldsUpdates}}", pointerFieldInits)
			res = strings.ReplaceAll(res, "{{InsertionPointForPointerFieldIDUpdates}}", pointerFieldIDInits)

			res = strings.ReplaceAll(res, "{{InsertionForModelToORMReversePointerSetup}}", modelToORMPointerOfArrayRedeem)
			res = strings.ReplaceAll(res, "{{InsertionForORMToModelArrayOfPointersRedeem}}", ORMToModelPointerOfArrayRedeem)

			res = replace2(res, "{{Structname}}", _struct.Name, "{{structname}}", lowerCaseStructName)
			fmt.Fprint(f, res)
		}

		defer f.Close()

	}
}
