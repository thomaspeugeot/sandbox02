// generated by genORMModelDB.go
package orm

import (
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gorgo/go/models"
)

// ClassshapeAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model classshapeAPI
type ClassshapeAPI struct {
	models.Classshape

	// association fields

	// field Position is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable a GORM `HAS ONE` association
	PositionID *uint

	// the associated Struct has a Name field, therefore it is generated to compute views with this relation
	PositionName string

	// ID generated for the implementation of the field Classshape{}.Classshapes []*Classdiagram
	Classdiagram_ClassshapesDBID uint
}

// ClassshapeDB describes a classshape in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model classshapeDB
type ClassshapeDB struct {
	gorm.Model

	ClassshapeAPI
}

// ClassshapeDBs arrays classshapeDBs
// swagger:response classshapeDBsResponse
type ClassshapeDBs []ClassshapeDB

// ClassshapeDBResponse provides response
// swagger:response classshapeDBResponse
type ClassshapeDBResponse struct {
	ClassshapeDB
}

// ModelToORMClassshapeTranslate is a translation function from models object to ORM objects
func ModelToORMClassshapeTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that classshapeStore is nil as well as classshapeDBs
		if map_ClassshapeDBID_ClassshapePtr != nil {
			err := errors.New("In CreateMode translation, map_ClassshapeDBID_ClassshapePtr should be nil")
			return err
		}

		if map_ClassshapeDBID_ClassshapeDB != nil {
			err := errors.New("In CreateMode translation, map_ClassshapeDBID_ClassshapeDB should be nil")
			return err
		}

		if map_ClassshapePtr_ClassshapeDBID != nil {
			err := errors.New("In CreateMode translation, map_ClassshapePtr_ClassshapeDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.Classshape, 0)
		map_ClassshapeDBID_ClassshapePtr = &tmp

		tmpDB := make(map[uint]*ClassshapeDB, 0)
		map_ClassshapeDBID_ClassshapeDB = &tmpDB

		tmpID := make(map[*models.Classshape]uint, 0)
		map_ClassshapePtr_ClassshapeDBID = &tmpID

		for _, classshape := range models.AllModelStore.Classshapes {

			// initiate classshape
			var classshapeDB ClassshapeDB
			classshapeDB.Classshape = *classshape

			query := db.Create(&classshapeDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_ClassshapePtr_ClassshapeDBID)[classshape] = classshapeDB.ID
			(*map_ClassshapeDBID_ClassshapePtr)[classshapeDB.ID] = classshape
			(*map_ClassshapeDBID_ClassshapeDB)[classshapeDB.ID] = &classshapeDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that classshapeStore is not nil
		if map_ClassshapeDBID_ClassshapePtr == nil {
			err := errors.New("In UpdateMode translation, classshapeStore should not be nil")
			return err
		}

		if map_ClassshapeDBID_ClassshapeDB == nil {
			err := errors.New("In UpdateMode translation, classshapeStore should not be nil")
			return err
		}

		// update fields of classshapeDB with fields of classshape
		for _, classshape := range models.AllModelStore.Classshapes {
			classshapeDBID := (*map_ClassshapePtr_ClassshapeDBID)[classshape]
			classshapeDB := (*map_ClassshapeDBID_ClassshapeDB)[classshapeDBID]

			classshapeDB.Classshape = *classshape
		}

		// parse model objects ot update associations
		for idx, classshape := range *map_ClassshapeDBID_ClassshapePtr {

			// fetch matching classshapeDB
			if classshapeDB, ok := (*map_ClassshapeDBID_ClassshapeDB)[idx]; ok {
				// set {{Fieldname}}ID

				// set PositionID
				if classshape.Position != nil {
					if positionId, ok := (*map_PositionPtr_PositionDBID)[classshape.Position]; ok {
						classshapeDB.PositionID = &positionId
					}
				}

				// set FieldsIDs reverse pointer to Field
				for _, Field := range classshape.Fields {
					if FieldDBID, ok := (*map_FieldPtr_FieldDBID)[Field]; ok {
						if FieldDB, ok := (*map_FieldDBID_FieldDB)[FieldDBID]; ok {
							FieldDB.Classshape_FieldsDBID = classshapeDB.ID
							if q := db.Save(&FieldDB); q.Error != nil {
								return q.Error
							}
						}
					}
				}

				// set LinksIDs reverse pointer to Link
				for _, Link := range classshape.Links {
					if LinkDBID, ok := (*map_LinkPtr_LinkDBID)[Link]; ok {
						if LinkDB, ok := (*map_LinkDBID_LinkDB)[LinkDBID]; ok {
							LinkDB.Classshape_LinksDBID = classshapeDB.ID
							if q := db.Save(&LinkDB); q.Error != nil {
								return q.Error
							}
						}
					}
				}

				query := db.Save(&classshapeDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, classshapeStore should not be nil %v %v",
						classshapeDB, classshape))
				return err
			}
		}
	}
	return nil
}

// stores ClassshapeDB according to their gorm ID
var map_ClassshapeDBID_ClassshapeDB *map[uint]*ClassshapeDB

// stores ClassshapeDB ID according to Classshape address
var map_ClassshapePtr_ClassshapeDBID *map[*models.Classshape]uint

// stores Classshape according to their gorm ID
var map_ClassshapeDBID_ClassshapePtr *map[uint]*models.Classshape

// ORMToModelClassshapeTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelClassshapeTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that classshapeStores are nil

		if map_ClassshapeDBID_ClassshapePtr != nil {
			err := errors.New("In CreateMode translation, Parameters classshapeStore should be nil")
			return err
		}

		if map_ClassshapeDBID_ClassshapeDB != nil {
			err := errors.New("In CreateMode translation, parameters ClassshapeDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.Classshape, 0)
		map_ClassshapeDBID_ClassshapePtr = &tmp

		tmpDB := make(map[uint]*ClassshapeDB, 0)
		map_ClassshapeDBID_ClassshapeDB = &tmpDB

		tmpID := make(map[*models.Classshape]uint, 0)
		map_ClassshapePtr_ClassshapeDBID = &tmpID

		models.AllModelStore.Classshapes = make([]*models.Classshape, 0)

		classshapeDBArray := make([]ClassshapeDB, 0)
		query := db.Find(&classshapeDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, classshapeDB := range classshapeDBArray {

			// create entries in the tree maps.
			classshape := classshapeDB.Classshape
			(*map_ClassshapeDBID_ClassshapePtr)[classshapeDB.ID] = &classshape

			(*map_ClassshapePtr_ClassshapeDBID)[&classshape] = classshapeDB.ID

			classshapeDBCopy := classshapeDB
			(*map_ClassshapeDBID_ClassshapeDB)[classshapeDB.ID] = &classshapeDBCopy

			// append model store with the new element
			models.AllModelStore.Classshapes = append(models.AllModelStore.Classshapes, &classshape)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that classshapeStore is not nil
		if map_ClassshapeDBID_ClassshapePtr == nil {
			err := errors.New("In UpdateMode translation, classshapeStore should not be nil")
			return err
		}

		if map_ClassshapeDBID_ClassshapeDB == nil {
			err := errors.New("In UpdateMode translation, classshapeStore should not be nil")
			return err
		}

		// update fields of classshapeDB with fields of classshape
		for _, classshape := range models.AllModelStore.Classshapes {
			classshapeDBID := (*map_ClassshapePtr_ClassshapeDBID)[classshape]
			classshapeDB := (*map_ClassshapeDBID_ClassshapeDB)[classshapeDBID]

			*classshape = classshapeDB.Classshape
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, classshapeDB := range *map_ClassshapeDBID_ClassshapeDB {
			classshape := (*map_ClassshapeDBID_ClassshapePtr)[classshapeDB.ID]
			if classshape == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}

			// Position field
			if classshapeDB.PositionID != nil {
				classshape.Position = (*map_PositionDBID_PositionPtr)[*(classshapeDB.PositionID)]
			}

			// parse all FieldDB and redeem the array of poiners to Classshape
			for _, FieldDB := range *map_FieldDBID_FieldDB {
				if FieldDB.Classshape_FieldsDBID == classshapeDB.ID {
					Field := (*map_FieldDBID_FieldPtr)[FieldDB.ID]
					classshape.Fields = append(classshape.Fields, Field)
				}
			}

			// parse all LinkDB and redeem the array of poiners to Classshape
			for _, LinkDB := range *map_LinkDBID_LinkDB {
				if LinkDB.Classshape_LinksDBID == classshapeDB.ID {
					Link := (*map_LinkDBID_LinkPtr)[LinkDB.ID]
					classshape.Links = append(classshape.Links, Link)
				}
			}

		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMClassshape(classshape *models.Classshape) {

	CreateORMClassshape(allORMStoreStruct.db, classshape)
}

// CreateORMClassshape creates ORM{{Strucname}} in DB from classshape
func CreateORMClassshape(
	db *gorm.DB,
	classshape *models.Classshape) (Error error) {

	// initiate classshape
	var classshapeDB ClassshapeDB
	classshapeDB.Classshape = *classshape

	query := db.Create(&classshapeDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_ClassshapePtr_ClassshapeDBID)[classshape] = classshapeDB.ID
	(*map_ClassshapeDBID_ClassshapePtr)[classshapeDB.ID] = classshape
	(*map_ClassshapeDBID_ClassshapeDB)[classshapeDB.ID] = &classshapeDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMClassshape(classshape *models.Classshape) {

	DeleteORMClassshape(allORMStoreStruct.db, classshape)
}

func DeleteORMClassshape(
	db *gorm.DB,
	classshape *models.Classshape) (Error error) {

	classshapeDBID := (*map_ClassshapePtr_ClassshapeDBID)[classshape]
	classshapeDB := (*map_ClassshapeDBID_ClassshapeDB)[classshapeDBID]

	query := db.Unscoped().Delete(&classshapeDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_ClassshapePtr_ClassshapeDBID, classshape)
	delete(*map_ClassshapeDBID_ClassshapePtr, classshapeDB.ID)
	delete(*map_ClassshapeDBID_ClassshapeDB, classshapeDBID)

	return
}
