// generated by genORMModelDB.go
package orm

import (
	
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/metabaron/libs/gorgo/go/models"
)

// FieldAPI is the input in POST API
// 
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model fieldAPI
type FieldAPI struct {

	models.Field

	// association fields
	
	// ID generated for the implementation of the field Field{}.Fields []*Classshape
	Classshape_FieldsDBID uint

}

// FieldDB describes a field in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model fieldDB
type FieldDB struct {
	gorm.Model

	FieldAPI
}

// FieldDBs arrays fieldDBs
// swagger:response fieldDBsResponse
type FieldDBs []FieldDB

// FieldDBResponse provides response
// swagger:response fieldDBResponse
type FieldDBResponse struct {
	FieldDB
}

// ModelToORMFieldTranslate is a translation function from models object to ORM objects
func ModelToORMFieldTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that fieldStore is nil as well as fieldDBs
		if map_FieldDBID_FieldPtr != nil {
			err := errors.New("In CreateMode translation, map_FieldDBID_FieldPtr should be nil")
			return err
		}

		if map_FieldDBID_FieldDB != nil {
			err := errors.New("In CreateMode translation, map_FieldDBID_FieldDB should be nil")
			return err
		}

		if map_FieldPtr_FieldDBID != nil {
			err := errors.New("In CreateMode translation, map_FieldPtr_FieldDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.Field, 0)
		map_FieldDBID_FieldPtr = &tmp

		tmpDB := make(map[uint]*FieldDB, 0)
		map_FieldDBID_FieldDB = &tmpDB

		tmpID := make(map[*models.Field]uint, 0)
		map_FieldPtr_FieldDBID = &tmpID

		for _, field := range models.AllModelStore.Fields {

			// initiate field
			var fieldDB FieldDB
			fieldDB.Field = *field

			query := db.Create(&fieldDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_FieldPtr_FieldDBID)[field] = fieldDB.ID
			(*map_FieldDBID_FieldPtr)[fieldDB.ID] = field
			(*map_FieldDBID_FieldDB)[fieldDB.ID] = &fieldDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that fieldStore is not nil
		if map_FieldDBID_FieldPtr == nil {
			err := errors.New("In UpdateMode translation, fieldStore should not be nil")
			return err
		}

		if map_FieldDBID_FieldDB == nil {
			err := errors.New("In UpdateMode translation, fieldStore should not be nil")
			return err
		}

		// update fields of fieldDB with fields of field
		for _, field := range models.AllModelStore.Fields {
			fieldDBID := (*map_FieldPtr_FieldDBID)[field]
			fieldDB := (*map_FieldDBID_FieldDB)[fieldDBID]

			fieldDB.Field = *field
		}

		// parse model objects ot update associations
		for idx, field := range *map_FieldDBID_FieldPtr {

			// fetch matching fieldDB
			if fieldDB, ok := (*map_FieldDBID_FieldDB)[idx]; ok {
				// set {{Fieldname}}ID



				query := db.Save(&fieldDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, fieldStore should not be nil %v %v",
						fieldDB, field))
				return err
			}
		}
	}
	return nil
}

// stores FieldDB according to their gorm ID
var map_FieldDBID_FieldDB *map[uint]*FieldDB

// stores FieldDB ID according to Field address
var map_FieldPtr_FieldDBID *map[*models.Field]uint

// stores Field according to their gorm ID
var map_FieldDBID_FieldPtr *map[uint]*models.Field

// ORMToModelFieldTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelFieldTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that fieldStores are nil

		if map_FieldDBID_FieldPtr != nil {
			err := errors.New("In CreateMode translation, Parameters fieldStore should be nil")
			return err
		}

		if map_FieldDBID_FieldDB != nil {
			err := errors.New("In CreateMode translation, parameters FieldDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.Field, 0)
		map_FieldDBID_FieldPtr = &tmp

		tmpDB := make(map[uint]*FieldDB, 0)
		map_FieldDBID_FieldDB = &tmpDB

		tmpID := make(map[*models.Field]uint, 0)
		map_FieldPtr_FieldDBID = &tmpID

		models.AllModelStore.Fields = make([]*models.Field, 0)

		fieldDBArray := make([]FieldDB, 0)
		query := db.Find(&fieldDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, fieldDB := range fieldDBArray {

			// create entries in the tree maps.
			field := fieldDB.Field
			(*map_FieldDBID_FieldPtr)[fieldDB.ID] = &field

			(*map_FieldPtr_FieldDBID)[&field] = fieldDB.ID

			fieldDBCopy := fieldDB
			(*map_FieldDBID_FieldDB)[fieldDB.ID] = &fieldDBCopy

			// append model store with the new element
			models.AllModelStore.Fields = append(models.AllModelStore.Fields, &field)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that fieldStore is not nil
		if map_FieldDBID_FieldPtr == nil {
			err := errors.New("In UpdateMode translation, fieldStore should not be nil")
			return err
		}

		if map_FieldDBID_FieldDB == nil {
			err := errors.New("In UpdateMode translation, fieldStore should not be nil")
			return err
		}

		// update fields of fieldDB with fields of field
		for _, field := range models.AllModelStore.Fields {
			fieldDBID := (*map_FieldPtr_FieldDBID)[field]
			fieldDB := (*map_FieldDBID_FieldDB)[fieldDBID]

			*field = fieldDB.Field
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, fieldDB := range *map_FieldDBID_FieldDB {
			field := (*map_FieldDBID_FieldPtr)[fieldDB.ID]
			if field == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}




		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMField(field *models.Field) {

	CreateORMField(allORMStoreStruct.db, field)
}

// CreateORMField creates ORM{{Strucname}} in DB from field
func CreateORMField(
	db *gorm.DB,
	field *models.Field) (Error error) {

	// initiate field
	var fieldDB FieldDB
	fieldDB.Field = *field

	query := db.Create(&fieldDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_FieldPtr_FieldDBID)[field] = fieldDB.ID
	(*map_FieldDBID_FieldPtr)[fieldDB.ID] = field
	(*map_FieldDBID_FieldDB)[fieldDB.ID] = &fieldDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMField(field *models.Field) {

	DeleteORMField(allORMStoreStruct.db, field)
}


func DeleteORMField(
	db *gorm.DB,
	field *models.Field) (Error error) {

	fieldDBID := (*map_FieldPtr_FieldDBID)[field]
	fieldDB := (*map_FieldDBID_FieldDB)[fieldDBID]

	query := db.Unscoped().Delete(&fieldDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_FieldPtr_FieldDBID, field)
	delete(*map_FieldDBID_FieldPtr, fieldDB.ID)
	delete(*map_FieldDBID_FieldDB, fieldDBID)

	return
}
