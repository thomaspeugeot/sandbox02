// generated by genORMModelDB.go
package orm

import (
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gorgo/go/models"
)

// LinkAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model linkAPI
type LinkAPI struct {
	models.Link

	// association fields

	// field Middlevertice is a pointer to another Struct (optional or 0..1)
	// This field is generated into another field to enable a GORM `HAS ONE` association
	MiddleverticeID *uint

	// the associated Struct has a Name field, therefore it is generated to compute views with this relation
	MiddleverticeName string

	// ID generated for the implementation of the field Link{}.Links []*Classshape
	Classshape_LinksDBID uint
}

// LinkDB describes a link in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model linkDB
type LinkDB struct {
	gorm.Model

	LinkAPI
}

// LinkDBs arrays linkDBs
// swagger:response linkDBsResponse
type LinkDBs []LinkDB

// LinkDBResponse provides response
// swagger:response linkDBResponse
type LinkDBResponse struct {
	LinkDB
}

// ModelToORMLinkTranslate is a translation function from models object to ORM objects
func ModelToORMLinkTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that linkStore is nil as well as linkDBs
		if map_LinkDBID_LinkPtr != nil {
			err := errors.New("In CreateMode translation, map_LinkDBID_LinkPtr should be nil")
			return err
		}

		if map_LinkDBID_LinkDB != nil {
			err := errors.New("In CreateMode translation, map_LinkDBID_LinkDB should be nil")
			return err
		}

		if map_LinkPtr_LinkDBID != nil {
			err := errors.New("In CreateMode translation, map_LinkPtr_LinkDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.Link, 0)
		map_LinkDBID_LinkPtr = &tmp

		tmpDB := make(map[uint]*LinkDB, 0)
		map_LinkDBID_LinkDB = &tmpDB

		tmpID := make(map[*models.Link]uint, 0)
		map_LinkPtr_LinkDBID = &tmpID

		for _, link := range models.AllModelStore.Links {

			// initiate link
			var linkDB LinkDB
			linkDB.Link = *link

			query := db.Create(&linkDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_LinkPtr_LinkDBID)[link] = linkDB.ID
			(*map_LinkDBID_LinkPtr)[linkDB.ID] = link
			(*map_LinkDBID_LinkDB)[linkDB.ID] = &linkDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that linkStore is not nil
		if map_LinkDBID_LinkPtr == nil {
			err := errors.New("In UpdateMode translation, linkStore should not be nil")
			return err
		}

		if map_LinkDBID_LinkDB == nil {
			err := errors.New("In UpdateMode translation, linkStore should not be nil")
			return err
		}

		// update fields of linkDB with fields of link
		for _, link := range models.AllModelStore.Links {
			linkDBID := (*map_LinkPtr_LinkDBID)[link]
			linkDB := (*map_LinkDBID_LinkDB)[linkDBID]

			linkDB.Link = *link
		}

		// parse model objects ot update associations
		for idx, link := range *map_LinkDBID_LinkPtr {

			// fetch matching linkDB
			if linkDB, ok := (*map_LinkDBID_LinkDB)[idx]; ok {
				// set {{Fieldname}}ID

				// set MiddleverticeID
				if link.Middlevertice != nil {
					if middleverticeId, ok := (*map_VerticePtr_VerticeDBID)[link.Middlevertice]; ok {
						linkDB.MiddleverticeID = &middleverticeId
					}
				}

				query := db.Save(&linkDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, linkStore should not be nil %v %v",
						linkDB, link))
				return err
			}
		}
	}
	return nil
}

// stores LinkDB according to their gorm ID
var map_LinkDBID_LinkDB *map[uint]*LinkDB

// stores LinkDB ID according to Link address
var map_LinkPtr_LinkDBID *map[*models.Link]uint

// stores Link according to their gorm ID
var map_LinkDBID_LinkPtr *map[uint]*models.Link

// ORMToModelLinkTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelLinkTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that linkStores are nil

		if map_LinkDBID_LinkPtr != nil {
			err := errors.New("In CreateMode translation, Parameters linkStore should be nil")
			return err
		}

		if map_LinkDBID_LinkDB != nil {
			err := errors.New("In CreateMode translation, parameters LinkDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.Link, 0)
		map_LinkDBID_LinkPtr = &tmp

		tmpDB := make(map[uint]*LinkDB, 0)
		map_LinkDBID_LinkDB = &tmpDB

		tmpID := make(map[*models.Link]uint, 0)
		map_LinkPtr_LinkDBID = &tmpID

		models.AllModelStore.Links = make([]*models.Link, 0)

		linkDBArray := make([]LinkDB, 0)
		query := db.Find(&linkDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, linkDB := range linkDBArray {

			// create entries in the tree maps.
			link := linkDB.Link
			(*map_LinkDBID_LinkPtr)[linkDB.ID] = &link

			(*map_LinkPtr_LinkDBID)[&link] = linkDB.ID

			linkDBCopy := linkDB
			(*map_LinkDBID_LinkDB)[linkDB.ID] = &linkDBCopy

			// append model store with the new element
			models.AllModelStore.Links = append(models.AllModelStore.Links, &link)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that linkStore is not nil
		if map_LinkDBID_LinkPtr == nil {
			err := errors.New("In UpdateMode translation, linkStore should not be nil")
			return err
		}

		if map_LinkDBID_LinkDB == nil {
			err := errors.New("In UpdateMode translation, linkStore should not be nil")
			return err
		}

		// update fields of linkDB with fields of link
		for _, link := range models.AllModelStore.Links {
			linkDBID := (*map_LinkPtr_LinkDBID)[link]
			linkDB := (*map_LinkDBID_LinkDB)[linkDBID]

			*link = linkDB.Link
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, linkDB := range *map_LinkDBID_LinkDB {
			link := (*map_LinkDBID_LinkPtr)[linkDB.ID]
			if link == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}

			// Middlevertice field
			if linkDB.MiddleverticeID != nil {
				link.Middlevertice = (*map_VerticeDBID_VerticePtr)[*(linkDB.MiddleverticeID)]
			}

		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMLink(link *models.Link) {

	CreateORMLink(allORMStoreStruct.db, link)
}

// CreateORMLink creates ORM{{Strucname}} in DB from link
func CreateORMLink(
	db *gorm.DB,
	link *models.Link) (Error error) {

	// initiate link
	var linkDB LinkDB
	linkDB.Link = *link

	query := db.Create(&linkDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_LinkPtr_LinkDBID)[link] = linkDB.ID
	(*map_LinkDBID_LinkPtr)[linkDB.ID] = link
	(*map_LinkDBID_LinkDB)[linkDB.ID] = &linkDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMLink(link *models.Link) {

	DeleteORMLink(allORMStoreStruct.db, link)
}

func DeleteORMLink(
	db *gorm.DB,
	link *models.Link) (Error error) {

	linkDBID := (*map_LinkPtr_LinkDBID)[link]
	linkDB := (*map_LinkDBID_LinkDB)[linkDBID]

	query := db.Unscoped().Delete(&linkDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_LinkPtr_LinkDBID, link)
	delete(*map_LinkDBID_LinkPtr, linkDB.ID)
	delete(*map_LinkDBID_LinkDB, linkDBID)

	return
}
