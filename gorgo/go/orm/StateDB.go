// generated by genORMModelDB.go
package orm

import (
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gorgo/go/models"
)

// StateAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model stateAPI
type StateAPI struct {
	models.State

	// association fields

	// ID generated for the implementation of the field State{}.States []*Umlsc
	Umlsc_StatesDBID uint
}

// StateDB describes a state in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model stateDB
type StateDB struct {
	gorm.Model

	StateAPI
}

// StateDBs arrays stateDBs
// swagger:response stateDBsResponse
type StateDBs []StateDB

// StateDBResponse provides response
// swagger:response stateDBResponse
type StateDBResponse struct {
	StateDB
}

// ModelToORMStateTranslate is a translation function from models object to ORM objects
func ModelToORMStateTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that stateStore is nil as well as stateDBs
		if map_StateDBID_StatePtr != nil {
			err := errors.New("In CreateMode translation, map_StateDBID_StatePtr should be nil")
			return err
		}

		if map_StateDBID_StateDB != nil {
			err := errors.New("In CreateMode translation, map_StateDBID_StateDB should be nil")
			return err
		}

		if map_StatePtr_StateDBID != nil {
			err := errors.New("In CreateMode translation, map_StatePtr_StateDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.State, 0)
		map_StateDBID_StatePtr = &tmp

		tmpDB := make(map[uint]*StateDB, 0)
		map_StateDBID_StateDB = &tmpDB

		tmpID := make(map[*models.State]uint, 0)
		map_StatePtr_StateDBID = &tmpID

		for _, state := range models.AllModelStore.States {

			// initiate state
			var stateDB StateDB
			stateDB.State = *state

			query := db.Create(&stateDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_StatePtr_StateDBID)[state] = stateDB.ID
			(*map_StateDBID_StatePtr)[stateDB.ID] = state
			(*map_StateDBID_StateDB)[stateDB.ID] = &stateDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that stateStore is not nil
		if map_StateDBID_StatePtr == nil {
			err := errors.New("In UpdateMode translation, stateStore should not be nil")
			return err
		}

		if map_StateDBID_StateDB == nil {
			err := errors.New("In UpdateMode translation, stateStore should not be nil")
			return err
		}

		// update fields of stateDB with fields of state
		for _, state := range models.AllModelStore.States {
			stateDBID := (*map_StatePtr_StateDBID)[state]
			stateDB := (*map_StateDBID_StateDB)[stateDBID]

			stateDB.State = *state
		}

		// parse model objects ot update associations
		for idx, state := range *map_StateDBID_StatePtr {

			// fetch matching stateDB
			if stateDB, ok := (*map_StateDBID_StateDB)[idx]; ok {
				// set {{Fieldname}}ID

				query := db.Save(&stateDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, stateStore should not be nil %v %v",
						stateDB, state))
				return err
			}
		}
	}
	return nil
}

// stores StateDB according to their gorm ID
var map_StateDBID_StateDB *map[uint]*StateDB

// stores StateDB ID according to State address
var map_StatePtr_StateDBID *map[*models.State]uint

// stores State according to their gorm ID
var map_StateDBID_StatePtr *map[uint]*models.State

// ORMToModelStateTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelStateTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that stateStores are nil

		if map_StateDBID_StatePtr != nil {
			err := errors.New("In CreateMode translation, Parameters stateStore should be nil")
			return err
		}

		if map_StateDBID_StateDB != nil {
			err := errors.New("In CreateMode translation, parameters StateDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.State, 0)
		map_StateDBID_StatePtr = &tmp

		tmpDB := make(map[uint]*StateDB, 0)
		map_StateDBID_StateDB = &tmpDB

		tmpID := make(map[*models.State]uint, 0)
		map_StatePtr_StateDBID = &tmpID

		models.AllModelStore.States = make([]*models.State, 0)

		stateDBArray := make([]StateDB, 0)
		query := db.Find(&stateDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, stateDB := range stateDBArray {

			// create entries in the tree maps.
			state := stateDB.State
			(*map_StateDBID_StatePtr)[stateDB.ID] = &state

			(*map_StatePtr_StateDBID)[&state] = stateDB.ID

			stateDBCopy := stateDB
			(*map_StateDBID_StateDB)[stateDB.ID] = &stateDBCopy

			// append model store with the new element
			models.AllModelStore.States = append(models.AllModelStore.States, &state)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that stateStore is not nil
		if map_StateDBID_StatePtr == nil {
			err := errors.New("In UpdateMode translation, stateStore should not be nil")
			return err
		}

		if map_StateDBID_StateDB == nil {
			err := errors.New("In UpdateMode translation, stateStore should not be nil")
			return err
		}

		// update fields of stateDB with fields of state
		for _, state := range models.AllModelStore.States {
			stateDBID := (*map_StatePtr_StateDBID)[state]
			stateDB := (*map_StateDBID_StateDB)[stateDBID]

			*state = stateDB.State
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, stateDB := range *map_StateDBID_StateDB {
			state := (*map_StateDBID_StatePtr)[stateDB.ID]
			if state == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}

		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMState(state *models.State) {

	CreateORMState(allORMStoreStruct.db, state)
}

// CreateORMState creates ORM{{Strucname}} in DB from state
func CreateORMState(
	db *gorm.DB,
	state *models.State) (Error error) {

	// initiate state
	var stateDB StateDB
	stateDB.State = *state

	query := db.Create(&stateDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_StatePtr_StateDBID)[state] = stateDB.ID
	(*map_StateDBID_StatePtr)[stateDB.ID] = state
	(*map_StateDBID_StateDB)[stateDB.ID] = &stateDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMState(state *models.State) {

	DeleteORMState(allORMStoreStruct.db, state)
}

func DeleteORMState(
	db *gorm.DB,
	state *models.State) (Error error) {

	stateDBID := (*map_StatePtr_StateDBID)[state]
	stateDB := (*map_StateDBID_StateDB)[stateDBID]

	query := db.Unscoped().Delete(&stateDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_StatePtr_StateDBID, state)
	delete(*map_StateDBID_StatePtr, stateDB.ID)
	delete(*map_StateDBID_StateDB, stateDBID)

	return
}
