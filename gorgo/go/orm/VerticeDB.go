// generated by genORMModelDB.go
package orm

import (
	"errors"
	"fmt"

	"github.com/jinzhu/gorm"
	"github.com/thomaspeugeot/sandbox02/gorgo/go/models"
)

// VerticeAPI is the input in POST API
//
// for POST, API, one needs the fields of the model as well as the fields
// from associations ("Has One" and "Has Many") that are generated to
// fullfill the ORM requirements for associations
//
// swagger:model verticeAPI
type VerticeAPI struct {
	models.Vertice

	// association fields

}

// VerticeDB describes a vertice in the database
//
// It incorporates all fields : from the model, from the generated field for the API and the GORM ID
//
// swagger:model verticeDB
type VerticeDB struct {
	gorm.Model

	VerticeAPI
}

// VerticeDBs arrays verticeDBs
// swagger:response verticeDBsResponse
type VerticeDBs []VerticeDB

// VerticeDBResponse provides response
// swagger:response verticeDBResponse
type VerticeDBResponse struct {
	VerticeDB
}

// ModelToORMVerticeTranslate is a translation function from models object to ORM objects
func ModelToORMVerticeTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that verticeStore is nil as well as verticeDBs
		if map_VerticeDBID_VerticePtr != nil {
			err := errors.New("In CreateMode translation, map_VerticeDBID_VerticePtr should be nil")
			return err
		}

		if map_VerticeDBID_VerticeDB != nil {
			err := errors.New("In CreateMode translation, map_VerticeDBID_VerticeDB should be nil")
			return err
		}

		if map_VerticePtr_VerticeDBID != nil {
			err := errors.New("In CreateMode translation, map_VerticePtr_VerticeDBID should be nil")
			return err
		}

		tmp := make(map[uint]*models.Vertice, 0)
		map_VerticeDBID_VerticePtr = &tmp

		tmpDB := make(map[uint]*VerticeDB, 0)
		map_VerticeDBID_VerticeDB = &tmpDB

		tmpID := make(map[*models.Vertice]uint, 0)
		map_VerticePtr_VerticeDBID = &tmpID

		for _, vertice := range models.AllModelStore.Vertices {

			// initiate vertice
			var verticeDB VerticeDB
			verticeDB.Vertice = *vertice

			query := db.Create(&verticeDB)
			if query.Error != nil {
				return query.Error
			}

			// update stores
			(*map_VerticePtr_VerticeDBID)[vertice] = verticeDB.ID
			(*map_VerticeDBID_VerticePtr)[verticeDB.ID] = vertice
			(*map_VerticeDBID_VerticeDB)[verticeDB.ID] = &verticeDB
		}
	} else { // UpdateMode, update IDs of Pointer Fields of ORM object

		// check that verticeStore is not nil
		if map_VerticeDBID_VerticePtr == nil {
			err := errors.New("In UpdateMode translation, verticeStore should not be nil")
			return err
		}

		if map_VerticeDBID_VerticeDB == nil {
			err := errors.New("In UpdateMode translation, verticeStore should not be nil")
			return err
		}

		// update fields of verticeDB with fields of vertice
		for _, vertice := range models.AllModelStore.Vertices {
			verticeDBID := (*map_VerticePtr_VerticeDBID)[vertice]
			verticeDB := (*map_VerticeDBID_VerticeDB)[verticeDBID]

			verticeDB.Vertice = *vertice
		}

		// parse model objects ot update associations
		for idx, vertice := range *map_VerticeDBID_VerticePtr {

			// fetch matching verticeDB
			if verticeDB, ok := (*map_VerticeDBID_VerticeDB)[idx]; ok {
				// set {{Fieldname}}ID

				query := db.Save(&verticeDB)
				if query.Error != nil {
					return query.Error
				}

			} else {
				err := errors.New(
					fmt.Sprintf("In UpdateMode translation, verticeStore should not be nil %v %v",
						verticeDB, vertice))
				return err
			}
		}
	}
	return nil
}

// stores VerticeDB according to their gorm ID
var map_VerticeDBID_VerticeDB *map[uint]*VerticeDB

// stores VerticeDB ID according to Vertice address
var map_VerticePtr_VerticeDBID *map[*models.Vertice]uint

// stores Vertice according to their gorm ID
var map_VerticeDBID_VerticePtr *map[uint]*models.Vertice

// ORMToModelVerticeTranslate is a translation function from ORM object to models objects
// This function used the uint ID of the ORM object to create or update (according to translationImpact)
// maps of respectively ORM and models objects
//
// In create mode,
func ORMToModelVerticeTranslate(
	translationImpact TranslationImpact,
	db *gorm.DB) (Error error) {

	if translationImpact == CreateMode {

		// check that verticeStores are nil

		if map_VerticeDBID_VerticePtr != nil {
			err := errors.New("In CreateMode translation, Parameters verticeStore should be nil")
			return err
		}

		if map_VerticeDBID_VerticeDB != nil {
			err := errors.New("In CreateMode translation, parameters VerticeDBStore should be nil")
			return err
		}

		// init stores
		tmp := make(map[uint]*models.Vertice, 0)
		map_VerticeDBID_VerticePtr = &tmp

		tmpDB := make(map[uint]*VerticeDB, 0)
		map_VerticeDBID_VerticeDB = &tmpDB

		tmpID := make(map[*models.Vertice]uint, 0)
		map_VerticePtr_VerticeDBID = &tmpID

		models.AllModelStore.Vertices = make([]*models.Vertice, 0)

		verticeDBArray := make([]VerticeDB, 0)
		query := db.Find(&verticeDBArray)
		if query.Error != nil {
			return query.Error
		}

		// copy orm objects to the two stores
		for _, verticeDB := range verticeDBArray {

			// create entries in the tree maps.
			vertice := verticeDB.Vertice
			(*map_VerticeDBID_VerticePtr)[verticeDB.ID] = &vertice

			(*map_VerticePtr_VerticeDBID)[&vertice] = verticeDB.ID

			verticeDBCopy := verticeDB
			(*map_VerticeDBID_VerticeDB)[verticeDB.ID] = &verticeDBCopy

			// append model store with the new element
			models.AllModelStore.Vertices = append(models.AllModelStore.Vertices, &vertice)
		}
	} else { // UpdateMode
		// for later, update of the data field

		// check that verticeStore is not nil
		if map_VerticeDBID_VerticePtr == nil {
			err := errors.New("In UpdateMode translation, verticeStore should not be nil")
			return err
		}

		if map_VerticeDBID_VerticeDB == nil {
			err := errors.New("In UpdateMode translation, verticeStore should not be nil")
			return err
		}

		// update fields of verticeDB with fields of vertice
		for _, vertice := range models.AllModelStore.Vertices {
			verticeDBID := (*map_VerticePtr_VerticeDBID)[vertice]
			verticeDB := (*map_VerticeDBID_VerticeDB)[verticeDBID]

			*vertice = verticeDB.Vertice
		}

		// parse all DB instance and update all pointer fields of the translated models instance
		for _, verticeDB := range *map_VerticeDBID_VerticeDB {
			vertice := (*map_VerticeDBID_VerticePtr)[verticeDB.ID]
			if vertice == nil {
				err := errors.New("cannot find translated instance in models store")
				return err
			}

		}
	}

	return nil
}

func (allORMStoreStruct *AllORMStoreStruct) CreateORMVertice(vertice *models.Vertice) {

	CreateORMVertice(allORMStoreStruct.db, vertice)
}

// CreateORMVertice creates ORM{{Strucname}} in DB from vertice
func CreateORMVertice(
	db *gorm.DB,
	vertice *models.Vertice) (Error error) {

	// initiate vertice
	var verticeDB VerticeDB
	verticeDB.Vertice = *vertice

	query := db.Create(&verticeDB)
	if query.Error != nil {
		return query.Error
	}

	// update stores
	(*map_VerticePtr_VerticeDBID)[vertice] = verticeDB.ID
	(*map_VerticeDBID_VerticePtr)[verticeDB.ID] = vertice
	(*map_VerticeDBID_VerticeDB)[verticeDB.ID] = &verticeDB

	return
}

func (allORMStoreStruct *AllORMStoreStruct) DeleteORMVertice(vertice *models.Vertice) {

	DeleteORMVertice(allORMStoreStruct.db, vertice)
}

func DeleteORMVertice(
	db *gorm.DB,
	vertice *models.Vertice) (Error error) {

	verticeDBID := (*map_VerticePtr_VerticeDBID)[vertice]
	verticeDB := (*map_VerticeDBID_VerticeDB)[verticeDBID]

	query := db.Unscoped().Delete(&verticeDB)
	if query.Error != nil {
		return query.Error
	}

	delete(*map_VerticePtr_VerticeDBID, vertice)
	delete(*map_VerticeDBID_VerticePtr, verticeDB.ID)
	delete(*map_VerticeDBID_VerticeDB, verticeDBID)

	return
}
